using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO        // Subscribe to EffectManager events for logging
        _effectManager.EffectStatusChanged += (_, message) => LogMessage(message);

        // Subscribe to real Twitch events
        _eventSubClient.SubscriptionReceived += OnRealTwitchSubscription;
        _eventSubClient.BitsReceived += OnRealTwitchBits;
        _eventSubClient.FollowReceived += OnRealTwitchFollow;
        _eventSubClient.ConnectionStatusChanged += OnConnectionStatusChanged; System.Linq;
using System.Windows.Forms;
using System.Diagnostics;

namespace BetterGameShuffler.TwitchIntegration;

public class EffectTestModeForm : Form
{
    private readonly TwitchEffectSettings _settings = new();
    private readonly EffectManager _effectManager;
    private readonly TwitchEventSubClient _eventSubClient;
    private bool _isConnectedToLiveEvents = false;

    private readonly Button _chaosButton = new() { Text = "Test Chaos Shuffling", Size = new Size(150, 40) };
    private readonly Button _randomImageButton = new() { Text = "Test Random Image", Size = new Size(150, 40) };
    private readonly Button _blacklistButton = new() { Text = "Test Game Ban", Size = new Size(150, 40) };
    private readonly Button _colorFilterButton = new() { Text = "Test Color Filter", Size = new Size(150, 40) };
    private readonly Button _randomSoundButton = new() { Text = "Test Random Sound", Size = new Size(150, 40) };
    private readonly Button _staticHudButton = new() { Text = "Test HUD Overlay", Size = new Size(150, 40) };
    private readonly Button _mirrorModeButton = new() { Text = "Test Mirror Mode", Size = new Size(150, 40) };
    private readonly Button _clearAllButton = new() { Text = "Clear All Effects", Size = new Size(150, 40), BackColor = Color.LightCoral };
    private readonly Button _scanFormatsButton = new() { Text = "Scan Image Formats", Size = new Size(150, 40), BackColor = Color.LightGreen };
    private readonly Button _debugSettingsButton = new() { Text = "Debug Settings", Size = new Size(150, 40), BackColor = Color.LightYellow };
    private readonly Button _twitchSettingsButton = new() { Text = "Twitch Settings", Size = new Size(150, 40), BackColor = Color.LightBlue };
    private readonly Button _clearActiveEffectsButton = new() { Text = "Clear Active Effects", Size = new Size(150, 40), BackColor = Color.Orange };
    private readonly Button _connectLiveEventsButton = new() { Text = "Connect Live Events", Size = new Size(150, 40), BackColor = Color.LightBlue };

    // Add Twitch Test Buttons
    private readonly Button _testSingleSubButton = new() { Text = "Test Single Sub", Size = new Size(150, 40), BackColor = Color.LightSalmon };
    private readonly Button _testGiftSubsButton = new() { Text = "Test Gift Subs", Size = new Size(150, 40), BackColor = Color.LightSalmon };
    private readonly Button _testBitsButton = new() { Text = "Test Bits", Size = new Size(150, 40), BackColor = Color.LightSalmon };
    private readonly Button _testGameBanDirectButton = new() { Text = "Test Game Ban Direct", Size = new Size(150, 40), BackColor = Color.IndianRed };

    private readonly NumericUpDown _durationSeconds = new() { Minimum = 1, Maximum = 300, Value = 15, Size = new Size(80, 25) };
    private readonly CheckBox _stackEffects = new() { Text = "Stack Effects", Checked = true, AutoSize = true };
    private readonly CheckBox _queueEffects = new() { Text = "Queue Effects", AutoSize = true };

    // Directory Settings Controls
    private readonly TextBox _imagesDirectoryTextBox = new() { Size = new Size(200, 25), Text = "images" };
    private readonly TextBox _soundsDirectoryTextBox = new() { Size = new Size(200, 25), Text = "sounds" };
    private readonly TextBox _hudDirectoryTextBox = new() { Size = new Size(200, 25), Text = "hud" };
    private readonly Button _browseImagesButton = new() { Text = "Browse...", Size = new Size(75, 25) };
    private readonly Button _browseSoundsButton = new() { Text = "Browse...", Size = new Size(75, 25) };
    private readonly Button _browseHudButton = new() { Text = "Browse...", Size = new Size(75, 25) };
    private readonly Button _resetDirectoriesButton = new() { Text = "Reset Defaults", Size = new Size(100, 25), BackColor = Color.LightBlue };
    private readonly Button _saveSettingsButton = new() { Text = "Save Settings", Size = new Size(100, 25), BackColor = Color.LightGreen };

    private readonly Label _statusLabel = new() { Text = "Effect Test Mode - Configure directories and test effects", AutoSize = true, Font = new Font("Segoe UI", 10, FontStyle.Bold) };
    private readonly TextBox _logTextBox = new() { Multiline = true, ScrollBars = ScrollBars.Vertical, ReadOnly = true, Size = new Size(500, 150) };

    // Twitch Test Controls
    private readonly NumericUpDown _testGiftCount = new() { Minimum = 1, Maximum = 100, Value = 5, Size = new Size(60, 25) };
    private readonly NumericUpDown _testBitsAmount = new() { Minimum = 1, Maximum = 10000, Value = 300, Size = new Size(80, 25) };
    private readonly ComboBox _testSubTier = new() { Size = new Size(100, 25) };

    public EffectTestModeForm(TwitchEffectSettings settings, MainForm? mainForm = null, EffectManager? existingEffectManager = null)
    {
        _settings = settings;

        // CRITICAL FIX: Use the existing EffectManager if provided, otherwise create new one
        // This ensures test mode uses the same EffectManager instance as the real shuffler
        if (existingEffectManager != null)
        {
            _effectManager = existingEffectManager;
            Debug.WriteLine("EffectTestModeForm: Using existing EffectManager instance from MainForm");
        }
        else
        {
            _effectManager = new EffectManager(mainForm, settings);
            Debug.WriteLine("EffectTestModeForm: Created new EffectManager instance");
        }

        // Initialize EventSub client for real Twitch events
        var twitchClient = new TwitchClient();
        twitchClient.SetCredentials(_settings.TwitchClientId, _settings.TwitchClientSecret);
        twitchClient.AccessToken = _settings.TwitchAccessToken;
        twitchClient.Username = _settings.TwitchChannelName;

        _eventSubClient = new TwitchEventSubClient(twitchClient);

        InitializeForm();
        SetupEventHandlers();
        LoadDirectorySettings();

        // Subscribe to EffectManager events for logging
        _effectManager.EffectStatusChanged += (_, message) => LogMessage(message);

        // Subscribe to real Twitch events - these handlers will be added later when needed
        // _eventSubClient.SubscriptionReceived += OnRealTwitchSubscription;
        // _eventSubClient.BitsReceived += OnRealTwitchBits;
        // _eventSubClient.FollowReceived += OnRealTwitchFollow;
        _eventSubClient.ConnectionStatusChanged += (_, status) => LogMessage($"?? EventSub: {status}");
    }

    private void InitializeForm()
    {
        Text = "Effect Test Mode & Settings";
        Size = new Size(700, 900); // Increased from 850 to 900
        FormBorderStyle = FormBorderStyle.FixedDialog;
        MaximizeBox = false;
        StartPosition = FormStartPosition.CenterParent;

        var mainPanel = new TableLayoutPanel
        {
            Dock = DockStyle.Fill,
            ColumnCount = 3,
            RowCount = 11, // Reduced from 13 since blur directory removed
            Padding = new Padding(10)
        };

        // Add title
        mainPanel.Controls.Add(_statusLabel);
        mainPanel.SetColumnSpan(_statusLabel, 3);

        // Directory Settings Section
        var directorySectionLabel = new Label { Text = "Directory Settings:", AutoSize = true, Font = new Font("Segoe UI", 10, FontStyle.Bold) };
        mainPanel.Controls.Add(directorySectionLabel);
        mainPanel.SetColumnSpan(directorySectionLabel, 3);

        // Images Directory
        mainPanel.Controls.Add(new Label { Text = "Images Directory:", AutoSize = true });
        mainPanel.Controls.Add(_imagesDirectoryTextBox);
        mainPanel.Controls.Add(_browseImagesButton);

        // Sounds Directory
        mainPanel.Controls.Add(new Label { Text = "Sounds Directory:", AutoSize = true });
        mainPanel.Controls.Add(_soundsDirectoryTextBox);
        mainPanel.Controls.Add(_browseSoundsButton);

        // HUD Directory
        mainPanel.Controls.Add(new Label { Text = "HUD Directory:", AutoSize = true });
        mainPanel.Controls.Add(_hudDirectoryTextBox);
        mainPanel.Controls.Add(_browseHudButton);

        // Reset button
        mainPanel.Controls.Add(new Label()); // Spacer
        mainPanel.Controls.Add(_resetDirectoriesButton);
        mainPanel.Controls.Add(_saveSettingsButton);

        // Effect Settings Section
        var effectSectionLabel = new Label { Text = "Effect Settings:", AutoSize = true, Font = new Font("Segoe UI", 10, FontStyle.Bold) };
        mainPanel.Controls.Add(effectSectionLabel);
        mainPanel.SetColumnSpan(effectSectionLabel, 3);

        // Add duration control
        var durationPanel = new FlowLayoutPanel { FlowDirection = FlowDirection.LeftToRight, AutoSize = true };
        durationPanel.Controls.AddRange(new Control[]
        {
            new Label { Text = "Duration (seconds):", AutoSize = true },
            _durationSeconds
        });

        // Add effect mode controls
        var modePanel = new FlowLayoutPanel { FlowDirection = FlowDirection.LeftToRight, AutoSize = true };
        modePanel.Controls.AddRange(new Control[] { _stackEffects, _queueEffects });

        mainPanel.Controls.Add(durationPanel);
        mainPanel.SetColumnSpan(durationPanel, 3);
        mainPanel.Controls.Add(modePanel);
        mainPanel.SetColumnSpan(modePanel, 3);

        // Twitch Test Settings Section
        var twitchTestSectionLabel = new Label { Text = "Twitch Test Settings:", AutoSize = true, Font = new Font("Segoe UI", 10, FontStyle.Bold) };
        mainPanel.Controls.Add(twitchTestSectionLabel);
        mainPanel.SetColumnSpan(twitchTestSectionLabel, 3);

        // Add Twitch test controls
        var twitchTestPanel = new FlowLayoutPanel { FlowDirection = FlowDirection.LeftToRight, AutoSize = true };

        // Sub tier dropdown
        _testSubTier.Items.AddRange(new[] { "Tier 1", "Tier 2", "Tier 3", "Prime" });
        _testSubTier.SelectedIndex = 0;

        twitchTestPanel.Controls.AddRange(new Control[]
        {
            new Label { Text = "Sub Tier:", AutoSize = true },
            _testSubTier,
            new Label { Text = "Gift Count:", AutoSize = true },
            _testGiftCount,
            new Label { Text = "Bits:", AutoSize = true },
            _testBitsAmount
        });

        mainPanel.Controls.Add(twitchTestPanel);
        mainPanel.SetColumnSpan(twitchTestPanel, 3);

        // Test Buttons Section
        var testSectionLabel = new Label { Text = "Test Effects:", AutoSize = true, Font = new Font("Segoe UI", 10, FontStyle.Bold) };
        mainPanel.Controls.Add(testSectionLabel);
        mainPanel.SetColumnSpan(testSectionLabel, 3);

        // Create a flow panel for buttons
        var buttonPanel = new FlowLayoutPanel
        {
            FlowDirection = FlowDirection.LeftToRight,
            Size = new Size(650, 350), // Increased height to accommodate more buttons
            WrapContents = true
        };

        buttonPanel.Controls.AddRange(new Control[]
        {
            _chaosButton, _randomImageButton, _blacklistButton, _colorFilterButton,
            _randomSoundButton, _staticHudButton, _mirrorModeButton,
            _testSingleSubButton, _testGiftSubsButton, _testBitsButton, _testGameBanDirectButton,
            _clearAllButton, _scanFormatsButton, _debugSettingsButton,
            _clearActiveEffectsButton, _connectLiveEventsButton, _twitchSettingsButton
        });

        mainPanel.Controls.Add(buttonPanel);
        mainPanel.SetColumnSpan(buttonPanel, 3);

        // Add log area
        var logLabel = new Label { Text = "Test Log:", AutoSize = true, Font = new Font("Segoe UI", 10, FontStyle.Bold) };
        mainPanel.Controls.Add(logLabel);
        mainPanel.SetColumnSpan(logLabel, 3);

        mainPanel.Controls.Add(_logTextBox);
        mainPanel.SetColumnSpan(_logTextBox, 3);

        Controls.Add(mainPanel);
    }

    private void SetupEventHandlers()
    {
        _chaosButton.Click += async (_, __) => await TestEffect(TwitchEffectType.ChaosMode);
        _randomImageButton.Click += async (_, __) => await TestEffect(TwitchEffectType.RandomImage);
        _blacklistButton.Click += async (_, __) => await TestEffect(TwitchEffectType.BlacklistGame);
        _colorFilterButton.Click += async (_, __) => await TestEffect(TwitchEffectType.ColorFilter);
        _randomSoundButton.Click += async (_, __) => await TestEffect(TwitchEffectType.RandomSound);
        _staticHudButton.Click += async (_, __) => await TestEffect(TwitchEffectType.StaticHUD);
        _mirrorModeButton.Click += async (_, __) => await TestEffect(TwitchEffectType.MirrorMode);
        _clearAllButton.Click += (_, __) => ClearAllEffects();
        _scanFormatsButton.Click += (_, __) => LogImageFormats();
        _debugSettingsButton.Click += (_, __) => DebugEffectsAndSettings();
        _clearActiveEffectsButton.Click += (_, __) => ClearActiveEffects();
        _connectLiveEventsButton.Click += (_, __) => LogMessage("Live events functionality not implemented in this version");
        _twitchSettingsButton.Click += (_, __) => OpenTwitchSettings();

        // Twitch Test Button Event Handlers
        _testSingleSubButton.Click += async (_, __) => await TestSingleSubscription();
        _testGiftSubsButton.Click += async (_, __) => await TestGiftSubscriptions();
        _testBitsButton.Click += async (_, __) => await TestBitsDonation();
        _testGameBanDirectButton.Click += async (_, __) => await TestGameBanDirect();

        _stackEffects.CheckedChanged += (_, __) => UpdateEffectSettings();
        _queueEffects.CheckedChanged += (_, __) => UpdateEffectSettings();

        // Directory event handlers
        _browseImagesButton.Click += (_, __) => BrowseForDirectory(_imagesDirectoryTextBox, "Select Images Directory");
        _browseSoundsButton.Click += (_, __) => BrowseForDirectory(_soundsDirectoryTextBox, "Select Sounds Directory");
        _browseHudButton.Click += (_, __) => BrowseForDirectory(_hudDirectoryTextBox, "Select HUD Directory");
        _resetDirectoriesButton.Click += (_, __) => ResetDirectoriesToDefaults();
        _saveSettingsButton.Click += (_, __) => SaveSettingsManually();

        // Directory text changed handlers - Auto-save when text changes
        _imagesDirectoryTextBox.TextChanged += (_, __) => UpdateDirectorySettings();
        _soundsDirectoryTextBox.TextChanged += (_, __) => UpdateDirectorySettings();
        _hudDirectoryTextBox.TextChanged += (_, __) => UpdateDirectorySettings();
    }

    private void LoadDirectorySettings()
    {
        Debug.WriteLine("=== LoadDirectorySettings START ===");

        // Load from persistent storage and display the ACTUAL saved values
        var savedImages = _settings.ImagesDirectory;
        var savedSounds = _settings.SoundsDirectory;
        var savedHud = _settings.HudDirectory;

        Debug.WriteLine($"Loading saved values from Registry:");
        Debug.WriteLine($"  Images: '{savedImages}'");
        Debug.WriteLine($"  Sounds: '{savedSounds}'");
        Debug.WriteLine($"  HUD: '{savedHud}'");

        // Set the textboxes to show the actual saved values
        _imagesDirectoryTextBox.Text = savedImages;
        _soundsDirectoryTextBox.Text = savedSounds;
        _hudDirectoryTextBox.Text = savedHud;

        Debug.WriteLine($"Set textbox values:");
        Debug.WriteLine($"  Images TextBox: '{_imagesDirectoryTextBox.Text}'");
        Debug.WriteLine($"  Sounds TextBox: '{_soundsDirectoryTextBox.Text}'");
        Debug.WriteLine($"  HUD TextBox: '{_hudDirectoryTextBox.Text}'");

        LogMessage($"?? Loaded saved directory settings:");
        LogMessage($"  Images: '{savedImages}'");
        LogMessage($"  Sounds: '{savedSounds}'");
        LogMessage($"  HUD: '{savedHud}'");

        Debug.WriteLine("=== LoadDirectorySettings END ===");
    }

    private void UpdateDirectorySettings()
    {
        Debug.WriteLine("=== UpdateDirectorySettings START ===");
        Debug.WriteLine($"Form TextBox Values:");
        Debug.WriteLine($"  Images: '{_imagesDirectoryTextBox.Text}'");
        Debug.WriteLine($"  Sounds: '{_soundsDirectoryTextBox.Text}'");
        Debug.WriteLine($"  HUD: '{_hudDirectoryTextBox.Text}'");

        // Save to persistent storage automatically
        Debug.WriteLine("Setting _settings properties...");
        _settings.ImagesDirectory = _imagesDirectoryTextBox.Text;
        _settings.SoundsDirectory = _soundsDirectoryTextBox.Text;
        _settings.HudDirectory = _hudDirectoryTextBox.Text;

        Debug.WriteLine("Reading back _settings properties...");
        Debug.WriteLine($"  Images: '{_settings.ImagesDirectory}'");
        Debug.WriteLine($"  Sounds: '{_settings.SoundsDirectory}'");
        Debug.WriteLine($"  HUD: '{_settings.HudDirectory}'");

        // Ensure directories exist
        _settings.EnsureDirectoriesExist();

        LogMessage($"?? Directory settings saved: Images='{_settings.ImagesDirectory}', Sounds='{_settings.SoundsDirectory}', HUD='{_settings.HudDirectory}'");
        Debug.WriteLine("=== UpdateDirectorySettings END ===");
    }

    private void BrowseForDirectory(TextBox textBox, string description)
    {
        using var dialog = new FolderBrowserDialog
        {
            Description = description,
            SelectedPath = Directory.Exists(textBox.Text) ? Path.GetFullPath(textBox.Text) : Environment.CurrentDirectory,
            ShowNewFolderButton = true
        };

        if (dialog.ShowDialog() == DialogResult.OK)
        {
            textBox.Text = dialog.SelectedPath;
            LogMessage($"Selected directory: {dialog.SelectedPath}");
        }
    }

    private void ResetDirectoriesToDefaults()
    {
        _imagesDirectoryTextBox.Text = "images";
        _soundsDirectoryTextBox.Text = "sounds";
        _hudDirectoryTextBox.Text = "hud";
        LogMessage("?? Directory settings reset to defaults and saved");
    }

    private void SaveSettingsManually()
    {
        try
        {
            Debug.WriteLine("=== MANUAL SAVE SETTINGS START ===");

            // Force update settings (in case auto-save didn't trigger)
            UpdateDirectorySettings();

            // Verify what's actually in the Registry
            Debug.WriteLine("=== REGISTRY VERIFICATION ===");
            try
            {
                var regImages = Microsoft.Win32.Registry.GetValue(@"HKEY_CURRENT_USER\Software\BetterGameShuffler", "TwitchEffects_ImagesDirectory", "NOT_FOUND");
                var regSounds = Microsoft.Win32.Registry.GetValue(@"HKEY_CURRENT_USER\Software\BetterGameShuffler", "TwitchEffects_SoundsDirectory", "NOT_FOUND");
                var regHud = Microsoft.Win32.Registry.GetValue(@"HKEY_CURRENT_USER\Software\BetterGameShuffler", "TwitchEffects_HudDirectory", "NOT_FOUND");

                Debug.WriteLine($"Registry - Images: {regImages}");
                Debug.WriteLine($"Registry - Sounds: {regSounds}");
                Debug.WriteLine($"Registry - HUD: {regHud}");
            }
            catch (Exception regEx)
            {
                Debug.WriteLine($"Registry verification error: {regEx.Message}");
            }

            LogMessage("? Settings manually saved to Windows Registry");
            LogMessage("?? Registry location: HKEY_CURRENT_USER\\Software\\BetterGameShuffler");
            LogMessage("?? Check Debug Output for detailed Registry verification");
            Debug.WriteLine("=== MANUAL SAVE SETTINGS END ===");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error saving settings: {ex.Message}");
            Debug.WriteLine($"Manual save error: {ex}");
        }
    }

    private async System.Threading.Tasks.Task TestEffect(TwitchEffectType effectType)
    {
        var config = _settings.EffectConfigs[effectType];
        var duration = TimeSpan.FromSeconds((double)_durationSeconds.Value);

        LogMessage($"Testing {config.Name} for {duration.TotalSeconds}s...");

        try
        {
            await _effectManager.ApplyEffect(config, "TestUser", duration);
            LogMessage($"? {config.Name} applied successfully");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error applying {config.Name}: {ex.Message}");
        }
    }

    private void ClearAllEffects()
    {
        try
        {
            _effectManager.ClearAllEffects();
            LogMessage("? All effects cleared successfully");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error clearing effects: {ex.Message}");
        }
    }

    private void ClearActiveEffects()
    {
        try
        {
            var activeCount = _effectManager.GetActiveEffects().Count;
            var queuedCount = _effectManager.GetQueuedEffectCount();

            _effectManager.ClearAllEffects();

            LogMessage($"?? Cleared {activeCount} active effects and {queuedCount} queued effects");
            LogMessage("? All effects cleared - you can now test subscriptions without queue/stack interference");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error clearing effects: {ex.Message}");
        }
    }

    private void UpdateEffectSettings()
    {
        _effectManager.StackEffects = _stackEffects.Checked;
        _effectManager.QueueEffects = _queueEffects.Checked;

        // Ensure only one mode is active
        if (_stackEffects.Checked && _queueEffects.Checked)
        {
            // Determine which checkbox was just changed by checking which one triggered this event
            var stackEffectsChanged = _stackEffects.Checked != _effectManager.StackEffects;
            if (stackEffectsChanged)
                _queueEffects.Checked = false;
            else
                _stackEffects.Checked = false;
        }

        LogMessage($"Effect mode updated: Stack={_effectManager.StackEffects}, Queue={_effectManager.QueueEffects}");
    }

    private void LogMessage(string message)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss");
        var logEntry = $"[{timestamp}] {message}";

        _logTextBox.AppendText(logEntry + Environment.NewLine);
        _logTextBox.SelectionStart = _logTextBox.Text.Length;
        _logTextBox.ScrollToCaret();
    }

    private void OpenTwitchSettings()
    {
        try
        {
            using var twitchSettingsForm = new TwitchSettingsForm(_settings);

            // Subscribe to test events from the Twitch settings form
            twitchSettingsForm.TestEventTriggered += OnTwitchTestEvent;

            LogMessage("?? Opening Twitch settings...");

            var result = twitchSettingsForm.ShowDialog();

            if (result == DialogResult.OK)
            {
                LogMessage("? Twitch settings saved successfully!");
                LogMessage($"?? Integration enabled: {_settings.TwitchIntegrationEnabled}");
                LogMessage($"?? Channel: {_settings.TwitchChannelName}");
                LogMessage($"?? Enabled effects: {_settings.GetEnabledEffects().Count}");

                // Update effect manager settings
                _effectManager.StackEffects = _settings.StackEffects;
                _effectManager.QueueEffects = _settings.QueueEffects;

                // CRITICAL: Reload EffectManager's settings from registry after user saves
                _effectManager.ReloadSettingsFromRegistry();
                LogMessage("?? EffectManager settings reloaded from registry");
            }
            else
            {
                LogMessage("? Twitch settings cancelled");
            }
        }
        catch (Exception ex)
        {
            LogMessage($"? Error opening Twitch settings: {ex.Message}");
            MessageBox.Show($"Error opening Twitch settings: {ex.Message}",
                "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }
    }

    private async void OnTwitchTestEvent(object? sender, TwitchEventArgs e)
    {
        LogMessage($"?? Twitch Test Event: {e.Username} - {e.Message}");
        LogMessage($"?? Debug - Bits: {e.Bits}, GiftCount: {e.GiftCount}, SubTier: {e.SubTier}");

        // Comprehensive debug check
        DebugEffectsAndSettings();

        try
        {
            // Check if this is a Game Ban test specifically
            if (e.Message.Contains("Game Ban") || e.Username == "TestBanner")
            {
                LogMessage($"?? GAME BAN TEST DETECTED - Forcing Game Ban effect with ForceGameBanEffect");

                var duration = _settings.GetSubEffectDuration(e.SubTier);
                await _effectManager.ForceGameBanEffect(e.Username, duration,
                    $"Forced Game Ban Test ({e.SubTier})", e.SubTier);

                LogMessage($"? Forced Game Ban effect applied for {e.Username} - GUARANTEED to work");
                return;
            }

            // Force reload effect configs to ensure they're current
            _settings.LoadEffectConfigsFromRegistry();
            var enabledEffects = _settings.GetEnabledEffects();
            LogMessage($"?? Reloaded effects - {enabledEffects.Count} enabled effects found");

            if (enabledEffects.Count == 0)
            {
                LogMessage($"? NO EFFECTS ENABLED - Cannot process {e.Username}'s event");
                LogMessage($"?? Use 'Debug Settings' to enable effects automatically");
                return;
            }

            if (e.Bits > 0)
            {
                // Handle bits donation
                LogMessage($"?? Routing to HandleTwitchBits with {e.Bits} bits");
                LogMessage($"?? Available effects: {string.Join(", ", enabledEffects.Select(ef => ef.Name))}");
                await _effectManager.HandleTwitchBits(e.Username, e.Bits);
                LogMessage($"? Processed {e.Bits} bits test");
            }
            else if (e.GiftCount > 1)
            {
                // Handle gift subscriptions (multiple subs)
                LogMessage($"?? Routing to HandleTwitchSubscription with {e.GiftCount} gift subs");
                LogMessage($"?? Available effects: {string.Join(", ", enabledEffects.Select(ef => ef.Name))}");
                await _effectManager.HandleTwitchSubscription(e.Username, e.SubTier, e.GiftCount);
                LogMessage($"? Processed {e.GiftCount}x {e.SubTier} gift subscription test");
            }
            else
            {
                // Handle single subscription
                LogMessage($"? Routing to HandleTwitchSubscription with single sub");
                LogMessage($"? Available effects: {string.Join(", ", enabledEffects.Select(ef => ef.Name))}");
                await _effectManager.HandleTwitchSubscription(e.Username, e.SubTier, 1);
                LogMessage($"? Processed single {e.SubTier} subscription test");
            }
        }
        catch (Exception ex)
        {
            LogMessage($"? Error processing Twitch test event: {ex.Message}");
            LogMessage($"?? Stack trace: {ex.StackTrace}");
        }
    }

    private void DebugEffectsAndSettings()
    {
        LogMessage("=== EFFECTS AND SETTINGS DEBUG ===");

        // Check EffectManager settings
        LogMessage($"?? EffectManager settings:");
        LogMessage($"  - StackEffects: {_effectManager.StackEffects}");
        LogMessage($"  - QueueEffects: {_effectManager.QueueEffects}");
        LogMessage($"  - Active effects count: {_effectManager.GetActiveEffects().Count}");
        LogMessage($"  - Queued effects count: {_effectManager.GetQueuedEffectCount()}");

        // Check enabled effects
        var enabledEffects = _settings.GetEnabledEffects();
        LogMessage($"?? Total enabled effects: {enabledEffects.Count}");

        if (enabledEffects.Count == 0)
        {
            LogMessage("? ERROR: NO EFFECTS ARE ENABLED!");
            LogMessage("?? Would you like to enable all effects automatically?");

            var result = MessageBox.Show(
                "No effects are currently enabled!\n\n" +
                "This is why Test Gift Subs and Test Single Sub don't work.\n\n" +
                "Would you like to enable all effects now?",
                "No Effects Enabled",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (result == DialogResult.Yes)
            {
                try
                {
                    TwitchSettingsReset.EnableAllEffects();

                    // Reload the effect configs to reflect the changes
                    _settings.LoadEffectConfigsFromRegistry();

                    LogMessage("? All effects have been enabled!");
                    LogMessage("?? You can now test Gift Subs and Single Subs successfully!");

                    MessageBox.Show(
                        "? All effects have been enabled!\n\n" +
                        "You can now test Gift Subs and Single Subs successfully!",
                        "Effects Enabled",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                }
                catch (Exception ex)
                {
                    LogMessage($"? Error enabling effects: {ex.Message}");
                    MessageBox.Show($"Error enabling effects: {ex.Message}", "Error",
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }
        else
        {
            LogMessage("? Enabled effects:");
            foreach (var effect in enabledEffects)
            {
                LogMessage($"  - {effect.Name} ({effect.Type})");
            }
        }

        // Check all effect states
        LogMessage("?? All effect configurations:");
        foreach (var kvp in _settings.EffectConfigs)
        {
            var effect = kvp.Value;
            LogMessage($"  - {effect.Name}: {(effect.Enabled ? "? ENABLED" : "? DISABLED")}");
        }

        // Check settings values
        LogMessage("?? Current settings:");
        LogMessage($"  - Integration Enabled: {_settings.TwitchIntegrationEnabled}");
        LogMessage($"  - Channel: '{_settings.TwitchChannelName}'");
        LogMessage($"  - Authenticated: {_settings.IsAuthenticated}");
        LogMessage($"  - Tier1 Duration: {_settings.Tier1SubDuration}s");
        LogMessage($"  - Tier2 Duration: {_settings.Tier2SubDuration}s");
        LogMessage($"  - Tier3 Duration: {_settings.Tier3SubDuration}s");
        LogMessage($"  - Prime Duration: {_settings.PrimeSubDuration}s>");
        LogMessage($"  - Bits per second: {_settings.BitsPerSecond}");
        LogMessage($"  - Max effects: {_settings.MaxSimultaneousEffects}");
        LogMessage($"  - Effect delay: {_settings.MultiEffectDelayMs}ms");

        // Registry debug info
        LogMessage("?? Registry debug info:");
        TwitchSettingsReset.DebugRegistryValues();

        LogMessage("=== END DEBUG ===");

        // Offer comprehensive reset if settings seem corrupted
        if (_settings.Tier1SubDuration == 0 || _settings.MaxSimultaneousEffects == 0)
        {
            LogMessage("?? WARNING: Some settings have invalid values (0)");

            var resetResult = MessageBox.Show(
                "Some settings appear to be corrupted (have value 0).\n\n" +
                "This can cause issues with effect duration and functionality.\n\n" +
                "Would you like to reset all Twitch settings to defaults?",
                "Corrupted Settings Detected",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (resetResult == DialogResult.Yes)
            {
                try
                {
                    TwitchSettingsReset.ResetAllTwitchSettings();
                    LogMessage("? All Twitch settings have been reset to defaults!");
                    MessageBox.Show(
                        "? All Twitch settings have been reset to defaults!\n\n" +
                        "Please restart the application for changes to take full effect.",
                        "Settings Reset",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                }
                catch (Exception ex)
                {
                    LogMessage($"? Error resetting settings: {ex.Message}");
                    MessageBox.Show($"Error resetting settings: {ex.Message}", "Error",
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }
    }

    private void OnEffectApplied(object? sender, TwitchEffectEventArgs e)
    {
        LogMessage($"?? Effect Applied: {e.Effect.Name} by {e.Username} ({e.Trigger}) - Duration: {e.Duration.TotalSeconds}s");
    }

    private void OnEffectStatusChanged(object? sender, string message)
    {
        LogMessage(message);
    }

    private void LogImageFormats()
    {
        try
        {
            LogMessage("=== Scanning for supported image formats ===");

            var directories = new[] { _settings.ImagesDirectory, _settings.HudDirectory };
            var totalFiles = 0;
            var formatCounts = new Dictionary<string, int>();

            foreach (var dir in directories)
            {
                LogMessage($"Checking directory: {Path.GetFullPath(dir)}");

                if (!Directory.Exists(dir))
                {
                    LogMessage($"  Directory does not exist, creating it...");
                    Directory.CreateDirectory(dir);
                    continue;
                }

                var files = ImageLoader.GetSupportedImageFiles(dir);
                LogMessage($"{dir}/ folder: {files.Length} files found");

                foreach (var file in files)
                {
                    var formatInfo = ImageLoader.GetImageFormatInfo(file);
                    var fileName = Path.GetFileName(file);
                    LogMessage($"  - {fileName}: {formatInfo}");

                    var extension = Path.GetExtension(file).ToLowerInvariant();
                    formatCounts[extension] = formatCounts.GetValueOrDefault(extension, 0) + 1;
                    totalFiles++;
                }
            }

            LogMessage($"=== Summary: {totalFiles} total image files ===");
            foreach (var kvp in formatCounts.OrderBy(k => k.Key))
            {
                LogMessage($"  {kvp.Key}: {kvp.Value} files");
            }

            if (totalFiles == 0)
            {
                LogMessage("No image files found. Add images to your configured directories to test!");
                LogMessage($"Current directories: Images='{Path.GetFullPath(_settings.ImagesDirectory)}', HUD='{Path.GetFullPath(_settings.HudDirectory)}'");
                LogMessage("");
                LogMessage("??? WEBP TROUBLESHOOTING TIPS:");
                LogMessage("� WebP files require Windows 10 (1903+) or Windows 11");
                LogMessage("� Large WebP files may cause OutOfMemoryException");
                LogMessage("� Try adding some PNG or JPG files as fallbacks");
                LogMessage("� Check if WebP codec is installed from Microsoft Store");
                LogMessage("");
                LogMessage("?? CREATING TEST FALLBACK IMAGES...");
                CreateTestFallbackImages();
            }
            else
            {
                // Count WebP vs other formats
                var webpCount = formatCounts.GetValueOrDefault(".webp", 0);
                var otherCount = totalFiles - webpCount;

                if (webpCount > 0 && otherCount == 0)
                {
                    LogMessage("");
                    LogMessage("??  WARNING: Only WebP files detected!");
                    LogMessage("� Consider adding PNG/JPG files as fallbacks");
                    LogMessage("� WebP support varies by Windows version");
                    LogMessage("");
                    LogMessage("?? CREATING TEST FALLBACK IMAGES...");
                    CreateTestFallbackImages();
                }
                else if (webpCount > 0)
                {
                    LogMessage("");
                    LogMessage($"? Good mix: {webpCount} WebP files + {otherCount} other formats");
                }
            }
        }
        catch (Exception ex)
        {
            LogMessage($"Error scanning image formats: {ex.Message}");
        }
    }

    private void CreateTestFallbackImages()
    {
        try
        {
            var imagesDir = Path.GetFullPath(_settings.ImagesDirectory);

            // Create a simple test PNG file
            var testImagePath = Path.Combine(imagesDir, "test_fallback.png");
            if (!File.Exists(testImagePath))
            {
                using var bitmap = new Bitmap(200, 200);
                using var graphics = Graphics.FromImage(bitmap);

                // Create a colorful test image
                graphics.Clear(Color.FromArgb(255, 100, 150, 255));
                using var brush = new SolidBrush(Color.White);
                using var font = new Font("Arial", 16, FontStyle.Bold);
                graphics.DrawString("TEST\nIMAGE", font, brush, new PointF(60, 80));

                bitmap.Save(testImagePath, System.Drawing.Imaging.ImageFormat.Png);
                LogMessage($"? Created test fallback image: {Path.GetFileName(testImagePath)}");
            }

            // Create another test image with different color
            var testImagePath2 = Path.Combine(imagesDir, "test_fallback2.png");
            if (!File.Exists(testImagePath2))
            {
                using var bitmap = new Bitmap(200, 200);
                using var graphics = Graphics.FromImage(bitmap);

                // Create a different colorful test image
                graphics.Clear(Color.FromArgb(255, 255, 100, 100));
                using var brush = new SolidBrush(Color.White);
                using var font = new Font("Arial", 16, FontStyle.Bold);
                graphics.DrawString("TEST\nIMAGE 2", font, brush, new PointF(45, 80));

                bitmap.Save(testImagePath2, System.Drawing.Imaging.ImageFormat.Png);
                LogMessage($"? Created test fallback image: {Path.GetFileName(testImagePath2)}");
            }

            LogMessage("? Fallback images created successfully!");
            LogMessage("� These PNG files should work while WebP issues are resolved");
            LogMessage("� Try the Random Image effect again");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error creating fallback images: {ex.Message}");
        }
    }

    protected override void OnFormClosing(FormClosingEventArgs e)
    {
        // Ensure settings are saved on close
        try
        {
            UpdateDirectorySettings();
            LogMessage("?? Final settings save completed");
        }
        catch (Exception ex)
        {
            LogMessage($"?? Warning: Could not save settings on close: {ex.Message}");
        }

        // Unsubscribe from events
        if (_effectManager != null)
        {
            _effectManager.EffectApplied -= OnEffectApplied;
            _effectManager.EffectStatusChanged -= OnEffectStatusChanged;
        }

        LogMessage("?? Test mode closing...");
        base.OnFormClosing(e);
    }

    protected override void OnFormClosed(FormClosedEventArgs e)
    {
        try
        {
            // Disconnect from live events when form closes
            _eventSubClient?.DisconnectAsync();
            _eventSubClient?.Dispose();
            _effectManager?.Dispose();
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"EffectTestModeForm: Disposal error: {ex.Message}");
        }

        base.OnFormClosed(e);
    }

    private SubTier GetSelectedSubTier()
    {
        return _testSubTier.SelectedIndex switch
        {
            0 => SubTier.Tier1,
            1 => SubTier.Tier2,
            2 => SubTier.Tier3,
            3 => SubTier.Prime,
            _ => SubTier.Tier1
        };
    }

    private async Task TestSingleSubscription()
    {
        var subTier = GetSelectedSubTier();
        LogMessage($"?? Testing Single {subTier} Subscription...");

        try
        {
            await _effectManager.HandleTwitchSubscription("TestSubscriber", subTier, 1);
            LogMessage($"? Single {subTier} subscription test completed");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error testing single subscription: {ex.Message}");
        }
    }

    private async Task TestGiftSubscriptions()
    {
        var subTier = GetSelectedSubTier();
        var giftCount = (int)_testGiftCount.Value;
        LogMessage($"?? Testing {giftCount}x {subTier} Gift Subscriptions...");

        try
        {
            await _effectManager.HandleTwitchSubscription("TestGifter", subTier, giftCount);
            LogMessage($"? {giftCount}x {subTier} gift subscription test completed");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error testing gift subscriptions: {ex.Message}");
        }
    }

    private async Task TestBitsDonation()
    {
        var bitsAmount = (int)_testBitsAmount.Value;
        LogMessage($"?? Testing {bitsAmount} Bits Donation...");

        try
        {
            await _effectManager.HandleTwitchBits("TestChatter", bitsAmount);
            LogMessage($"? {bitsAmount} bits donation test completed");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error testing bits donation: {ex.Message}");
        }
    }

    private async Task TestGameBanDirect()
    {
        var subTier = GetSelectedSubTier();
        var duration = TimeSpan.FromSeconds((double)_durationSeconds.Value);
        LogMessage($"?? Testing Direct Game Ban with {subTier} trigger...");

        try
        {
            // Use the new ForceGameBanEffect method for guaranteed Game Ban
            await _effectManager.ForceGameBanEffect("TestBanner", duration,
                $"Direct Game Ban Test ({subTier})", subTier);
            LogMessage($"? Direct Game Ban test completed - GUARANTEED Game Ban effect");
        }
        catch (Exception ex)
        {
            LogMessage($"? Error testing direct game ban: {ex.Message}");
        }
    }
}